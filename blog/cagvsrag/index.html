<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CAG vs RAG: A Developer's Journey | Anmol Gupta</title><meta name=keywords content><meta name=description content="A little background about me: I&rsquo;m a backend developer who spends most of my time with Node.js, TypeScript, AWS, and Kubernetes. Over the past year, I&rsquo;ve been exploring AI coding tools, and honestly? It&rsquo;s been quite a ride.
Starting with Cursor
Like many developers in early 2025, I jumped into Cursor. The auto-suggest feature was impressive in theory, but here&rsquo;s the thing—it kept nudging me toward its suggestions on every single line. I found myself constantly fighting against the flow rather than going with it. So I turned off auto-suggest entirely."><meta name=author content="Anmol Gupta"><link rel=canonical href=https://anmolgupta.github.io/blog/cagvsrag/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://anmolgupta.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://anmolgupta.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://anmolgupta.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://anmolgupta.github.io/apple-touch-icon.png><link rel=mask-icon href=https://anmolgupta.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://anmolgupta.github.io/blog/cagvsrag/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://anmolgupta.github.io/blog/cagvsrag/"><meta property="og:site_name" content="Anmol Gupta"><meta property="og:title" content="CAG vs RAG: A Developer's Journey"><meta property="og:description" content="A little background about me: I’m a backend developer who spends most of my time with Node.js, TypeScript, AWS, and Kubernetes. Over the past year, I’ve been exploring AI coding tools, and honestly? It’s been quite a ride.
Starting with Cursor Like many developers in early 2025, I jumped into Cursor. The auto-suggest feature was impressive in theory, but here’s the thing—it kept nudging me toward its suggestions on every single line. I found myself constantly fighting against the flow rather than going with it. So I turned off auto-suggest entirely."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2026-01-14T09:34:17-05:00"><meta property="article:modified_time" content="2026-01-14T09:34:17-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="CAG vs RAG: A Developer's Journey"><meta name=twitter:description content="A little background about me: I&rsquo;m a backend developer who spends most of my time with Node.js, TypeScript, AWS, and Kubernetes. Over the past year, I&rsquo;ve been exploring AI coding tools, and honestly? It&rsquo;s been quite a ride.
Starting with Cursor
Like many developers in early 2025, I jumped into Cursor. The auto-suggest feature was impressive in theory, but here&rsquo;s the thing—it kept nudging me toward its suggestions on every single line. I found myself constantly fighting against the flow rather than going with it. So I turned off auto-suggest entirely."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://anmolgupta.github.io/blog/"},{"@type":"ListItem","position":2,"name":"CAG vs RAG: A Developer's Journey","item":"https://anmolgupta.github.io/blog/cagvsrag/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CAG vs RAG: A Developer's Journey","name":"CAG vs RAG: A Developer\u0027s Journey","description":"A little background about me: I\u0026rsquo;m a backend developer who spends most of my time with Node.js, TypeScript, AWS, and Kubernetes. Over the past year, I\u0026rsquo;ve been exploring AI coding tools, and honestly? It\u0026rsquo;s been quite a ride.\nStarting with Cursor Like many developers in early 2025, I jumped into Cursor. The auto-suggest feature was impressive in theory, but here\u0026rsquo;s the thing—it kept nudging me toward its suggestions on every single line. I found myself constantly fighting against the flow rather than going with it. So I turned off auto-suggest entirely.\n","keywords":[],"articleBody":"A little background about me: I’m a backend developer who spends most of my time with Node.js, TypeScript, AWS, and Kubernetes. Over the past year, I’ve been exploring AI coding tools, and honestly? It’s been quite a ride.\nStarting with Cursor Like many developers in early 2025, I jumped into Cursor. The auto-suggest feature was impressive in theory, but here’s the thing—it kept nudging me toward its suggestions on every single line. I found myself constantly fighting against the flow rather than going with it. So I turned off auto-suggest entirely.\nWas that the “right” choice? Who knows. But it worked for me.\nWith auto-suggest off, I started using Cursor more selectively—writing the structure myself and calling on it when I needed help with specific functions or integrating services. It made me more productive, though I couldn’t quite measure by how much. (Sound familiar? We’re all trying to figure out how to quantify AI-assisted productivity.)\nThen I discovered Cursor’s planning feature. This was interesting—I could plan out features before diving into code. But I noticed something: it kept suggesting patterns from my existing codebase. Great for consistency, not so great for exploring new approaches. I rarely got to see what else was out there.\nDisclaimer: My experience spans Feb 2025 to Dec 2025. Cursor has probably evolved since then. If you’ve had different experiences, I’d love to hear about them.\nDiscovering Claude Code Around September 2025, I started experimenting with Claude Code. I was already using Cursor outside its main auto-suggest capability, so why not try something different?\nAt first, the planning experience felt similar—suggestions based on existing code patterns. But then I found something that clicked for me: when I explicitly asked Claude Code to show me patterns outside my current codebase during planning, it actually did.\nSuddenly, I had options. I could look at a feature implementation from two or three different angles, choose the one that fit both my taste and my team’s preferences, and this is the part I really valued—justify my choices with confidence. Every approach has trade-offs, but now I understood what I was trading and why.\nI got invested. I built custom commands, skills, and workflows. One of my favorites is a /research command that tells Claude to search the internet for answers rather than defaulting to the current codebase or context. It changed how I approached problems.\nHitting the Context Ceiling Here’s where it gets interesting. As my project grew, the benefits I was getting from Claude Code started diminishing. The codebase was simply getting too large for the context window to handle effectively.\nSo I started thinking about RAG (Retrieval-Augmented Generation). But wait—wasn’t that exactly what Cursor was doing all along? Searching my codebase and retrieving relevant context?\nI went back to Cursor. And you know what? It worked better this time. The project had matured. Patterns were established. Having RAG-style retrieval over a well-structured codebase actually made sense now.\nCAG vs RAG: It’s Not About Picking a Winner Looking back at this journey, another developer might look at my choices and disagree completely. And that’s okay. The trade-offs I made were based on my situation at that moment: the scale of the project, team size and expertise, time constraints, and cost considerations. None of those things stay constant.\nSo which is better: RAG or CAG (Context-Augmented Generation)?\nI don’t think that’s the right question. Here’s what I’ve been thinking about instead:\nCAG feels more powerful when you’re in exploration mode—researching, innovating, trying new approaches. Yes, you’re limited by context window size. But isn’t that constraint similar to what the industry already deals with? Large monolithic codebases become unmanageable, so we split them into microservices. Smaller contexts, distributed ownership, freedom to experiment within boundaries.\nRAG shines when you have an established codebase with clear patterns. It’s great for consistency and for working within existing structures.\nWhere Do You Want to Invest? Maybe the real question is: where do you want to put your effort?\nAre you okay with the network overhead of a microservice architecture while making a smaller investment in AI tooling with CAG? Or would you rather invest more heavily in RAG infrastructure to support a larger, unified codebase with minimal network complexity?\nThere’s no universal answer. Your mileage will vary. Your project will change. Your needs will evolve.\nThat’s the one thing I’m confident about: the situation will never stay the same, and the best approach is to stay adaptable rather than loyal to any single tool or strategy.\nWhat’s your experience been? I’d genuinely like to know.\n","wordCount":"760","inLanguage":"en","datePublished":"2026-01-14T09:34:17-05:00","dateModified":"2026-01-14T09:34:17-05:00","author":{"@type":"Person","name":"Anmol Gupta"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://anmolgupta.github.io/blog/cagvsrag/"},"publisher":{"@type":"Organization","name":"Anmol Gupta","logo":{"@type":"ImageObject","url":"https://anmolgupta.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://anmolgupta.github.io/ accesskey=h title="Anmol Gupta (Alt + H)">Anmol Gupta</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://anmolgupta.github.io/ title=Home><span>Home</span></a></li><li><a href=https://anmolgupta.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://anmolgupta.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://anmolgupta.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://anmolgupta.github.io/blog/>Posts</a></div><h1 class="post-title entry-hint-parent">CAG vs RAG: A Developer's Journey</h1><div class=post-meta><span title='2026-01-14 09:34:17 -0500 EST'>January 14, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Anmol Gupta</span></div></header><div class=post-content><p>A little background about me: I&rsquo;m a backend developer who spends most of my time with Node.js, TypeScript, AWS, and Kubernetes. Over the past year, I&rsquo;ve been exploring AI coding tools, and honestly? It&rsquo;s been quite a ride.</p><h2 id=starting-with-cursor>Starting with Cursor<a hidden class=anchor aria-hidden=true href=#starting-with-cursor>#</a></h2><p>Like many developers in early 2025, I jumped into Cursor. The auto-suggest feature was impressive in theory, but here&rsquo;s the thing—it kept nudging me toward its suggestions on every single line. I found myself constantly fighting against the flow rather than going with it. So I turned off auto-suggest entirely.</p><p>Was that the &ldquo;right&rdquo; choice? Who knows. But it worked for me.</p><p>With auto-suggest off, I started using Cursor more selectively—writing the structure myself and calling on it when I needed help with specific functions or integrating services. It made me more productive, though I couldn&rsquo;t quite measure by how much. (Sound familiar? We&rsquo;re all trying to figure out how to quantify AI-assisted productivity.)</p><p>Then I discovered Cursor&rsquo;s planning feature. This was interesting—I could plan out features before diving into code. But I noticed something: it kept suggesting patterns from my existing codebase. Great for consistency, not so great for exploring new approaches. I rarely got to see what else was out there.</p><p><em>Disclaimer: My experience spans Feb 2025 to Dec 2025. Cursor has probably evolved since then. If you&rsquo;ve had different experiences, I&rsquo;d love to hear about them.</em></p><h2 id=discovering-claude-code>Discovering Claude Code<a hidden class=anchor aria-hidden=true href=#discovering-claude-code>#</a></h2><p>Around September 2025, I started experimenting with Claude Code. I was already using Cursor outside its main auto-suggest capability, so why not try something different?</p><p>At first, the planning experience felt similar—suggestions based on existing code patterns. But then I found something that clicked for me: when I explicitly asked Claude Code to show me patterns <em>outside</em> my current codebase during planning, it actually did.</p><p>Suddenly, I had options. I could look at a feature implementation from two or three different angles, choose the one that fit both my taste and my team&rsquo;s preferences, and this is the part I really valued—justify my choices with confidence. Every approach has trade-offs, but now I understood what I was trading and why.</p><p>I got invested. I built custom commands, skills, and workflows. One of my favorites is a <code>/research</code> command that tells Claude to search the internet for answers rather than defaulting to the current codebase or context. It changed how I approached problems.</p><h2 id=hitting-the-context-ceiling>Hitting the Context Ceiling<a hidden class=anchor aria-hidden=true href=#hitting-the-context-ceiling>#</a></h2><p>Here&rsquo;s where it gets interesting. As my project grew, the benefits I was getting from Claude Code started diminishing. The codebase was simply getting too large for the context window to handle effectively.</p><p>So I started thinking about RAG (Retrieval-Augmented Generation). But wait—wasn&rsquo;t that exactly what Cursor was doing all along? Searching my codebase and retrieving relevant context?</p><p>I went back to Cursor. And you know what? It worked better this time. The project had matured. Patterns were established. Having RAG-style retrieval over a well-structured codebase actually made sense now.</p><h2 id=cag-vs-rag-its-not-about-picking-a-winner>CAG vs RAG: It&rsquo;s Not About Picking a Winner<a hidden class=anchor aria-hidden=true href=#cag-vs-rag-its-not-about-picking-a-winner>#</a></h2><p>Looking back at this journey, another developer might look at my choices and disagree completely. And that&rsquo;s okay. The trade-offs I made were based on my situation at that moment: the scale of the project, team size and expertise, time constraints, and cost considerations. None of those things stay constant.</p><p>So which is better: RAG or CAG (Context-Augmented Generation)?</p><p>I don&rsquo;t think that&rsquo;s the right question. Here&rsquo;s what I&rsquo;ve been thinking about instead:</p><p>CAG feels more powerful when you&rsquo;re in exploration mode—researching, innovating, trying new approaches. Yes, you&rsquo;re limited by context window size. But isn&rsquo;t that constraint similar to what the industry already deals with? Large monolithic codebases become unmanageable, so we split them into microservices. Smaller contexts, distributed ownership, freedom to experiment within boundaries.</p><p>RAG shines when you have an established codebase with clear patterns. It&rsquo;s great for consistency and for working within existing structures.</p><h2 id=where-do-you-want-to-invest>Where Do You Want to Invest?<a hidden class=anchor aria-hidden=true href=#where-do-you-want-to-invest>#</a></h2><p>Maybe the real question is: where do you want to put your effort?</p><p>Are you okay with the network overhead of a microservice architecture while making a smaller investment in AI tooling with CAG? Or would you rather invest more heavily in RAG infrastructure to support a larger, unified codebase with minimal network complexity?</p><p>There&rsquo;s no universal answer. Your mileage will vary. Your project will change. Your needs will evolve.</p><p>That&rsquo;s the one thing I&rsquo;m confident about: the situation will never stay the same, and the best approach is to stay adaptable rather than loyal to any single tool or strategy.</p><p>What&rsquo;s your experience been? I&rsquo;d genuinely like to know.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://anmolgupta.github.io/>Anmol Gupta</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>