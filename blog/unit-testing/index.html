<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Skill to Leverage Unit Testing | Anmol Gupta</title><meta name=keywords content><meta name=description content="After a decade of writing code professionally, I&rsquo;ve finally made peace with unit testing but it took years of doing it wrong first.
For most of my early career, I wrote unit-tests to satisfy code coverage requirements. If you&rsquo;ve worked on an established codebase, you know the pain: writing unit-tests eventually becomes more complex than writing the production code itself.
Adding new features to these codebases creates an uncomfortable dilemma. You can either introduce a new pattern that makes testing productive, or you follow existing conventions to avoid touching too much surface area. More often than not, developers choose the path of least resistance by writing logic first and then bolting on unit-tests afterward just to hit coverage numbers."><meta name=author content="Anmol Gupta"><link rel=canonical href=https://anmolgupta.github.io/blog/unit-testing/><link crossorigin=anonymous href=/assets/css/stylesheet.b51b3860271168cb321283046dd8261334ae31985975854bfdbb5991a60508a5.css integrity="sha256-tRs4YCcRaMsyEoMEbdgmEzSuMZhZdYVL/btZkaYFCKU=" rel="preload stylesheet" as=style><link rel=icon href=https://anmolgupta.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://anmolgupta.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://anmolgupta.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://anmolgupta.github.io/apple-touch-icon.png><link rel=mask-icon href=https://anmolgupta.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://anmolgupta.github.io/blog/unit-testing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://anmolgupta.github.io/blog/unit-testing/"><meta property="og:site_name" content="Anmol Gupta"><meta property="og:title" content="Skill to Leverage Unit Testing"><meta property="og:description" content="After a decade of writing code professionally, Iâ€™ve finally made peace with unit testing but it took years of doing it wrong first.
For most of my early career, I wrote unit-tests to satisfy code coverage requirements. If youâ€™ve worked on an established codebase, you know the pain: writing unit-tests eventually becomes more complex than writing the production code itself.
Adding new features to these codebases creates an uncomfortable dilemma. You can either introduce a new pattern that makes testing productive, or you follow existing conventions to avoid touching too much surface area. More often than not, developers choose the path of least resistance by writing logic first and then bolting on unit-tests afterward just to hit coverage numbers."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2026-01-10T10:43:12-05:00"><meta property="article:modified_time" content="2026-01-10T10:43:12-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Skill to Leverage Unit Testing"><meta name=twitter:description content="After a decade of writing code professionally, I&rsquo;ve finally made peace with unit testing but it took years of doing it wrong first.
For most of my early career, I wrote unit-tests to satisfy code coverage requirements. If you&rsquo;ve worked on an established codebase, you know the pain: writing unit-tests eventually becomes more complex than writing the production code itself.
Adding new features to these codebases creates an uncomfortable dilemma. You can either introduce a new pattern that makes testing productive, or you follow existing conventions to avoid touching too much surface area. More often than not, developers choose the path of least resistance by writing logic first and then bolting on unit-tests afterward just to hit coverage numbers."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://anmolgupta.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Skill to Leverage Unit Testing","item":"https://anmolgupta.github.io/blog/unit-testing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Skill to Leverage Unit Testing","name":"Skill to Leverage Unit Testing","description":"After a decade of writing code professionally, I\u0026rsquo;ve finally made peace with unit testing but it took years of doing it wrong first.\nFor most of my early career, I wrote unit-tests to satisfy code coverage requirements. If you\u0026rsquo;ve worked on an established codebase, you know the pain: writing unit-tests eventually becomes more complex than writing the production code itself.\nAdding new features to these codebases creates an uncomfortable dilemma. You can either introduce a new pattern that makes testing productive, or you follow existing conventions to avoid touching too much surface area. More often than not, developers choose the path of least resistance by writing logic first and then bolting on unit-tests afterward just to hit coverage numbers.\n","keywords":[],"articleBody":"After a decade of writing code professionally, Iâ€™ve finally made peace with unit testing but it took years of doing it wrong first.\nFor most of my early career, I wrote unit-tests to satisfy code coverage requirements. If youâ€™ve worked on an established codebase, you know the pain: writing unit-tests eventually becomes more complex than writing the production code itself.\nAdding new features to these codebases creates an uncomfortable dilemma. You can either introduce a new pattern that makes testing productive, or you follow existing conventions to avoid touching too much surface area. More often than not, developers choose the path of least resistance by writing logic first and then bolting on unit-tests afterward just to hit coverage numbers.\nThose test cases never helped anyone. They couldnâ€™t guide development or catch regressions meaningfully. Whatâ€™s labeled â€œquality assuranceâ€ quickly becomes technical debt, and the whole teamâ€™s productivity suffers debugging flaky test cases instead of shipping features.\nThrough these mistakes, I learned something crucial: testability must be designed in from the start, not retrofitted later. The key to getting this correct is Dependency Injection (DI). When you can inject dependencies into a class, youâ€™re no longer fighting the question of how do I mock this global import? You simply pass in mocks directly. Object-oriented design makes dependencies explicit and swappable.\nIâ€™ve intentionally chosen a complex code example here to demonstrate dealing with external dependencies. Bear with me, the payoff is worth it.\nLetâ€™s say you have this Express Service:\n// src/services/user.service.ts import { db } from \"../db/client\"; // Global import we want to mock import { logger } from \"../utils/logger\"; export class UserService { async getUser(id: string) { logger.info(`Fetching user ${id}`); const user = await db.query(\"SELECT * FROM users WHERE id = $1\", [id]); return user.rows[0]; } } Now adding a simple unit-test here looks like:\n// src/services/__tests__/user.service.test.ts import { UserService } from \"../user.service\"; // ============================================================================= // EXTRA OVERHEAD OF DEALING WITH GLOBAL IMPORTS // ============================================================================= // Mock the entire module BEFORE importing the service jest.mock(\"../../db/client\", () =\u003e ({ db: { query: jest.fn(), }, })); jest.mock(\"../../utils/logger\", () =\u003e ({ logger: { info: jest.fn(), error: jest.fn(), }, })); // Import the mocked module to control it in tests import { db } from \"../../db/client\"; // ============================================================================= // UNITL HERE // ============================================================================= describe(\"UserService\", () =\u003e { let service: UserService; beforeEach(() =\u003e { service = new UserService(); jest.clearAllMocks(); // Reset mock state between tests }); it(\"should fetch a user by id\", async () =\u003e { const mockUser = { id: \"123\", name: \"John Doe\" }; // Configure mock return value (db.query as jest.Mock).mockResolvedValue({ rows: [mockUser] }); const result = await service.getUser(\"123\"); expect(db.query).toHaveBeenCalledWith(\"SELECT * FROM users WHERE id = $1\", [ \"123\", ]); expect(result).toEqual(mockUser); }); it(\"should handle user not found\", async () =\u003e { (db.query as jest.Mock).mockResolvedValue({ rows: [] }); const result = await service.getUser(\"unknown\"); expect(result).toBeUndefined(); }); }); Now compare this with the same service using Dependency Injection:\n// src/services/user.service.ts import type { Database } from \"../db/types\"; import type { Logger } from \"../utils/types\"; export class UserService { constructor(private db: Database, private logger: Logger) {} async getUser(id: string) { this.logger.info(`Fetching user ${id}`); const user = await this.db.query(\"SELECT * FROM users WHERE id = $1\", [id]); return user.rows[0]; } } // ============================================================================= // TEST BEGINS // ============================================================================= import { UserService } from \"../user.service\"; describe(\"UserService\", () =\u003e { let service: UserService; let mockDb: { query: jest.Mock }; let mockLogger: { info: jest.Mock; error: jest.Mock }; beforeEach(() =\u003e { // Create fresh mocks for each test mockDb = { query: jest.fn() }; mockLogger = { info: jest.fn(), error: jest.fn() }; service = new UserService(mockDb, mockLogger); }); it(\"should fetch a user by id\", async () =\u003e { const mockUser = { id: \"123\", name: \"John Doe\" }; mockDb.query.mockResolvedValue({ rows: [mockUser] }); const result = await service.getUser(\"123\"); expect(mockDb.query).toHaveBeenCalledWith( \"SELECT * FROM users WHERE id = $1\", [\"123\"] ); expect(result).toEqual(mockUser); }); it(\"should handle user not found\", async () =\u003e { // Configure mock to return empty rows mockDb.query.mockResolvedValue({ rows: [] }); const result = await service.getUser(\"unknown\"); // Verify the query was called correctly expect(mockDb.query).toHaveBeenCalledWith( \"SELECT * FROM users WHERE id = $1\", [\"unknown\"] ); // Verify logger was called expect(mockLogger.info).toHaveBeenCalledWith(\"Fetching user unknown\"); // Result should be undefined when no rows returned expect(result).toBeUndefined(); }); }); The example above demonstrates how the DI pattern simplifies mocking by eliminating the need to globally mock imports in your test suite. This naturally raises the question: how do you implement DI with Express.js which is a framework designed around middlewares and functional programming?. One option is integrating a library like tsyringe with Express.js. However, if the overhead of adding a third-party DI library feels excessive, it might be worth considering Nest.js instead, which has DI built into its core architecture.\nWhile easier mocking is a nice benefit, the real power of DI becomes apparent when we want to write effective unit tests. In the next section, weâ€™ll explore how DI truly shines in making unit testing more practical and maintainable.\nThe FOUR Non-Negotiables of Effective Unit Tests 1. FAST The whole point of unit-tests is to save time for a developer. Test suit should run as quickly as hot reload responds to a code change with instant feedback. This is only possible when you mock external dependencies completely and run test cases in PARALLEL. If your test suite takes minutes, youâ€™ll stop running it.\nParallel Execution: The Global Imports Challenge // src/services/__tests__/user.service.test.ts import { UserService } from \"../user.service\"; // Mock the entire module BEFORE importing the service jest.mock(\"../../db/client\", () =\u003e ({ db: { query: jest.fn(), }, })); jest.mock(\"../../utils/logger\", () =\u003e ({ logger: { info: jest.fn(), error: jest.fn(), }, })); // Import the mocked module to control it in tests import { db } from \"../../db/client\"; import { logger } from \"../../utils/logger\"; describe(\"UserService\", () =\u003e { // âŒ REMOVED: shared `service` variable // âŒ REMOVED: beforeEach with service instantiation // âœ… Only clear mocks before each test beforeEach(() =\u003e { jest.clearAllMocks(); }); test.concurrent(\"should fetch a user by id\", async () =\u003e { // âœ… Create service INSIDE the test const service = new UserService(); const mockUser = { id: \"123\", name: \"John Doe\" }; // âœ… Use mockResolvedValueOnce (not mockResolvedValue) (db.query as jest.Mock).mockResolvedValueOnce({ rows: [mockUser] }); const result = await service.getUser(\"123\"); expect(db.query).toHaveBeenCalledWith(\"SELECT * FROM users WHERE id = $1\", [ \"123\", ]); expect(result).toEqual(mockUser); }); test.concurrent(\"should handle user not found\", async () =\u003e { // âœ… Create service INSIDE the test const service = new UserService(); // âœ… Use mockResolvedValueOnce (not mockResolvedValue) (db.query as jest.Mock).mockResolvedValueOnce({ rows: [] }); const result = await service.getUser(\"unknown\"); expect(db.query).toHaveBeenCalledWith(\"SELECT * FROM users WHERE id = $1\", [ \"unknown\", ]); expect(result).toBeUndefined(); }); }); Effortless Parallelization: The DI Advantage // src/services/__tests__/user.service.test.ts import { UserService } from \"../user.service\"; describe(\"UserService\", () =\u003e { // âŒ REMOVED: shared variables (service, mockDb, mockLogger) // âŒ REMOVED: beforeEach with shared setup // âœ… Helper to create fresh mocks for each test const createMocks = () =\u003e ({ mockDb: { query: jest.fn() }, mockLogger: { info: jest.fn(), error: jest.fn() }, }); test.concurrent(\"should fetch a user by id\", async () =\u003e { // âœ… Create fresh mocks INSIDE each test const { mockDb, mockLogger } = createMocks(); const service = new UserService(mockDb, mockLogger); const mockUser = { id: \"123\", name: \"John Doe\" }; mockDb.query.mockResolvedValue({ rows: [mockUser] }); const result = await service.getUser(\"123\"); expect(mockDb.query).toHaveBeenCalledWith( \"SELECT * FROM users WHERE id = $1\", [\"123\"] ); expect(result).toEqual(mockUser); }); test.concurrent(\"should handle user not found\", async () =\u003e { // âœ… Create fresh mocks INSIDE each test const { mockDb, mockLogger } = createMocks(); const service = new UserService(mockDb, mockLogger); mockDb.query.mockResolvedValue({ rows: [] }); const result = await service.getUser(\"unknown\"); expect(mockDb.query).toHaveBeenCalledWith( \"SELECT * FROM users WHERE id = $1\", [\"unknown\"] ); expect(mockLogger.info).toHaveBeenCalledWith(\"Fetching user unknown\"); expect(result).toBeUndefined(); }); }); DI gives each test case its own mock, so mockResolvedValue just works. When you mock at the import level, Jest creates a single mock instance thatâ€™s shared across all tests running in parallel. If you use mockResolvedValue instead of mockResolvedValueOnce, one testâ€™s setup can bleed into anotherâ€”leading to flaky failures that are notoriously hard to debug.\n2. Isolation Parallelism implies isolation. If your test cases run concurrently without failing, they have no shared state, no order dependencies, no hidden coupling. Test A canâ€™t break Test B.\n3. Repeatable A test case should give you the same result whether you run it once or a thousand times. Reformat your code, refactor internals, swap out the databaseâ€”No change. This leads to a critical point: test behavior, not implementation. The moment you assert â€œthis function was called exactly twice,â€ youâ€™re testing how something works, not what it does.\nThis is why the logger assertion in our example is problematic:\nâŒ expect(mockLogger.info).toHaveBeenCalledWith(\"Fetching user unknown\");\nThink about it: you could modify or remove this logging statement without breaking any functionality. That makes it an implementation detail, not a behavioral contract. Unit-tests that assert on implementation details break when you refactor which is exactly what repeatable guards against.\n4. AAA pattern (Arrange, Act, Assert) Structure matters. Every test-case should follow this pattern:\nArrange â€” set up your test data and dependencies Act â€” execute ONE thing (a single function call, one operation) Assert â€” verify the RETURNED values âŒ Multiple Acts in One Test-case import { UserService } from \"../user.service\"; describe(\"UserService\", () =\u003e { const createMocks = () =\u003e ({ mockDb: { query: jest.fn() }, mockLogger: { info: jest.fn(), error: jest.fn() }, }); // âŒ VIOLATION: Multiple Acts in one test-case it(\"should fetch and update user correctly\", async () =\u003e { // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• // ARRANGE // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• const { mockDb, mockLogger } = createMocks(); const service = new UserService(mockDb, mockLogger); const mockUser = { id: \"123\", name: \"John Doe\" }; const updatedUser = { id: \"123\", name: \"Jane Doe\" }; mockDb.query .mockResolvedValueOnce({ rows: [mockUser] }) // for getUser .mockResolvedValueOnce({ rows: [updatedUser] }); // for updateUser // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• // ACT #1 âŒ First action // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• const fetchedUser = await service.getUser(\"123\"); // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• // ASSERT #1 âŒ Intermediate assertion // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• expect(fetchedUser).toEqual(mockUser); // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• // ACT #2 âŒ Second action // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• const result = await service.updateUser(\"123\", { name: \"Jane Doe\" }); // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• // ASSERT #2 âŒ Final assertion // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• expect(result).toEqual(updatedUser); }); }); This is problematic since it is a Test Failure Debugging Nightmare.\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Test: \"should fetch and update user correctly\" â”‚ â”‚ Status: FAILED âŒ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Which action failed? â”‚ â”‚ â”œâ”€ getUser('123')? â”‚ â”‚ â””â”€ updateUser('123', ...)? â”‚ â”‚ â”‚ â”‚ Which assertion failed? â”‚ â”‚ â”œâ”€ fetchedUser equals mockUser? â”‚ â”‚ â”œâ”€ result equals updatedUser? â”‚ â”‚ â”‚ â”‚ ğŸ¤· Hard to tell without reading stack trace â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ âœ… Refactored into Separate Tests import { UserService } from \"../user.service\"; describe(\"UserService\", () =\u003e { const createMocks = () =\u003e ({ mockDb: { query: jest.fn() }, mockLogger: { info: jest.fn(), error: jest.fn() }, }); // âœ… Test 1: Single Act - getUser test.concurrent(\"should fetch a user by id\", async () =\u003e { // ARRANGE const { mockDb, mockLogger } = createMocks(); const service = new UserService(mockDb, mockLogger); const mockUser = { id: \"123\", name: \"John Doe\" }; mockDb.query.mockResolvedValue({ rows: [mockUser] }); // ACT (single action) const result = await service.getUser(\"123\"); // ASSERT expect(result).toEqual(mockUser); }); // âœ… Test 2: Single Act - updateUser test.concurrent(\"should update a user\", async () =\u003e { // ARRANGE const { mockDb, mockLogger } = createMocks(); const service = new UserService(mockDb, mockLogger); const updatedUser = { id: \"123\", name: \"Jane Doe\" }; mockDb.query.mockResolvedValue({ rows: [updatedUser] }); // ACT (single action) const result = await service.updateUser(\"123\", { name: \"Jane Doe\" }); // ASSERT expect(result).toEqual(updatedUser); }); // âœ… Test 3: Single Act - workflow (if testing integration) test.concurrent(\"should fetch user before update\", async () =\u003e { // ARRANGE const { mockDb, mockLogger } = createMocks(); const service = new UserService(mockDb, mockLogger); const mockUser = { id: \"123\", name: \"John Doe\" }; mockDb.query.mockResolvedValue({ rows: [mockUser] }); // ACT (single action - the workflow method) const result = await service.fetchAndUpdateUser(\"123\", { name: \"Jane\" }); // ASSERT expect(result.original.name).toBe(\"John Doe\"); expect(result.updated.name).toBe(\"Jane\"); }); }); The Bottom Line LLMs have fundamentally changed the economics of starting fresh. Prototyping is cheaper than ever. Setting up a project with testability as a first-class concern is no longer an expensive luxury but itâ€™s becoming the default. Feed these guidelines to an LLM, and it can generate code structured exactly the way you want. Thatâ€™s what weâ€™ll explore in the next post.\n","wordCount":"2052","inLanguage":"en","datePublished":"2026-01-10T10:43:12-05:00","dateModified":"2026-01-10T10:43:12-05:00","author":{"@type":"Person","name":"Anmol Gupta"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://anmolgupta.github.io/blog/unit-testing/"},"publisher":{"@type":"Organization","name":"Anmol Gupta","logo":{"@type":"ImageObject","url":"https://anmolgupta.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://anmolgupta.github.io/ accesskey=h title="Anmol Gupta (Alt + H)">Anmol Gupta</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://anmolgupta.github.io/ title=Home><span>Home</span></a></li><li><a href=https://anmolgupta.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://anmolgupta.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://anmolgupta.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://anmolgupta.github.io/blog/>Posts</a></div><h1 class="post-title entry-hint-parent">Skill to Leverage Unit Testing</h1><div class=post-meta><span title='2026-01-10 10:43:12 -0500 EST'>January 10, 2026</span>&nbsp;Â·&nbsp;<span>10 min</span>&nbsp;Â·&nbsp;<span>Anmol Gupta</span></div></header><div class=post-content><p>After a decade of writing code professionally, I&rsquo;ve finally made peace with unit testing but it took years of doing it wrong first.</p><p>For most of my early career, I wrote unit-tests to satisfy code coverage requirements. If you&rsquo;ve worked on an established codebase, you know the pain: writing unit-tests eventually becomes more complex than writing the production code itself.</p><p>Adding new features to these codebases creates an uncomfortable dilemma. You can either introduce a new pattern that makes testing productive, or you follow existing conventions to avoid touching too much surface area. More often than not, developers choose the path of least resistance by writing logic first and then bolting on unit-tests afterward just to hit coverage numbers.</p><p>Those test cases never helped anyone. They couldn&rsquo;t guide development or catch regressions meaningfully. What&rsquo;s labeled &ldquo;quality assurance&rdquo; quickly becomes technical debt, and the whole team&rsquo;s productivity suffers debugging flaky test cases instead of shipping features.</p><p>Through these mistakes, I learned something crucial: testability must be designed in from the start, not retrofitted later. The key to getting this correct is Dependency Injection (DI). When you can inject dependencies into a class, you&rsquo;re no longer fighting the question of <code>how do I mock this global import?</code> You simply pass in mocks directly. Object-oriented design makes dependencies explicit and swappable.</p><p>I&rsquo;ve intentionally chosen a complex code example here to demonstrate dealing with external dependencies. Bear with me, the payoff is worth it.</p><p>Let&rsquo;s say you have this Express Service:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#6272a4>// src/services/user.service.ts
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> { db } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../db/client&#34;</span>; <span style=color:#6272a4>// Global import we want to mock
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> { logger } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../utils/logger&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>export</span> <span style=color:#ff79c6>class</span> UserService {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>async</span> getUser(id: <span style=color:#8be9fd>string</span>) {
</span></span><span style=display:flex><span>    logger.info(<span style=color:#f1fa8c>`Fetching user </span><span style=color:#f1fa8c>${</span>id<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>`</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> user <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> db.query(<span style=color:#f1fa8c>&#34;SELECT * FROM users WHERE id = $1&#34;</span>, [id]);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> user.rows[<span style=color:#bd93f9>0</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now adding a simple unit-test here looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#6272a4>// src/services/__tests__/user.service.test.ts
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> { UserService } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../user.service&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// =============================================================================
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// EXTRA OVERHEAD OF DEALING WITH GLOBAL IMPORTS
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// =============================================================================
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Mock the entire module BEFORE importing the service
</span></span></span><span style=display:flex><span>jest.mock(<span style=color:#f1fa8c>&#34;../../db/client&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> ({
</span></span><span style=display:flex><span>  db<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>    query: <span style=color:#8be9fd>jest.fn</span>(),
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>}));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>jest.mock(<span style=color:#f1fa8c>&#34;../../utils/logger&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> ({
</span></span><span style=display:flex><span>  logger<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>    info: <span style=color:#8be9fd>jest.fn</span>(),
</span></span><span style=display:flex><span>    error: <span style=color:#8be9fd>jest.fn</span>(),
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>}));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Import the mocked module to control it in tests
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> { db } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../../db/client&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#6272a4>// =============================================================================
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// UNITL HERE
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// =============================================================================
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>describe(<span style=color:#f1fa8c>&#34;UserService&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> service: <span style=color:#8be9fd>UserService</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  beforeEach(() <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService();
</span></span><span style=display:flex><span>    jest.clearAllMocks(); <span style=color:#6272a4>// Reset mock state between tests
</span></span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  it(<span style=color:#f1fa8c>&#34;should fetch a user by id&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> mockUser <span style=color:#ff79c6>=</span> { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;123&#34;</span>, name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;John Doe&#34;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Configure mock return value
</span></span></span><span style=display:flex><span>    (db.query <span style=color:#ff79c6>as</span> jest.Mock).mockResolvedValue({ rows<span style=color:#ff79c6>:</span> [mockUser] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;123&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    expect(db.query).toHaveBeenCalledWith(<span style=color:#f1fa8c>&#34;SELECT * FROM users WHERE id = $1&#34;</span>, [
</span></span><span style=display:flex><span>      <span style=color:#f1fa8c>&#34;123&#34;</span>,
</span></span><span style=display:flex><span>    ]);
</span></span><span style=display:flex><span>    expect(result).toEqual(mockUser);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  it(<span style=color:#f1fa8c>&#34;should handle user not found&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    (db.query <span style=color:#ff79c6>as</span> jest.Mock).mockResolvedValue({ rows<span style=color:#ff79c6>:</span> [] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;unknown&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    expect(result).toBeUndefined();
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Now compare this with the same service using <strong>Dependency Injection</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#6272a4>// src/services/user.service.ts
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> <span style=color:#ff79c6>type</span> { Database } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../db/types&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> <span style=color:#ff79c6>type</span> { Logger } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../utils/types&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>export</span> <span style=color:#ff79c6>class</span> UserService {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>constructor</span>(<span style=color:#ff79c6>private</span> db: <span style=color:#8be9fd>Database</span>, <span style=color:#ff79c6>private</span> logger: <span style=color:#8be9fd>Logger</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>async</span> getUser(id: <span style=color:#8be9fd>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span>.logger.info(<span style=color:#f1fa8c>`Fetching user </span><span style=color:#f1fa8c>${</span>id<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>`</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> user <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> <span style=color:#ff79c6>this</span>.db.query(<span style=color:#f1fa8c>&#34;SELECT * FROM users WHERE id = $1&#34;</span>, [id]);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> user.rows[<span style=color:#bd93f9>0</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// =============================================================================
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// TEST BEGINS
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// =============================================================================
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> { UserService } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../user.service&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>describe(<span style=color:#f1fa8c>&#34;UserService&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> service: <span style=color:#8be9fd>UserService</span>;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> mockDb<span style=color:#ff79c6>:</span> { query: <span style=color:#8be9fd>jest.Mock</span> };
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> mockLogger<span style=color:#ff79c6>:</span> { info: <span style=color:#8be9fd>jest.Mock</span>; error: <span style=color:#8be9fd>jest.Mock</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  beforeEach(() <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Create fresh mocks for each test
</span></span></span><span style=display:flex><span>    mockDb <span style=color:#ff79c6>=</span> { query: <span style=color:#8be9fd>jest.fn</span>() };
</span></span><span style=display:flex><span>    mockLogger <span style=color:#ff79c6>=</span> { info: <span style=color:#8be9fd>jest.fn</span>(), error: <span style=color:#8be9fd>jest.fn</span>() };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService(mockDb, mockLogger);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  it(<span style=color:#f1fa8c>&#34;should fetch a user by id&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> mockUser <span style=color:#ff79c6>=</span> { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;123&#34;</span>, name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;John Doe&#34;</span> };
</span></span><span style=display:flex><span>    mockDb.query.mockResolvedValue({ rows<span style=color:#ff79c6>:</span> [mockUser] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;123&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    expect(mockDb.query).toHaveBeenCalledWith(
</span></span><span style=display:flex><span>      <span style=color:#f1fa8c>&#34;SELECT * FROM users WHERE id = $1&#34;</span>,
</span></span><span style=display:flex><span>      [<span style=color:#f1fa8c>&#34;123&#34;</span>]
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    expect(result).toEqual(mockUser);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  it(<span style=color:#f1fa8c>&#34;should handle user not found&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Configure mock to return empty rows
</span></span></span><span style=display:flex><span>    mockDb.query.mockResolvedValue({ rows<span style=color:#ff79c6>:</span> [] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;unknown&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Verify the query was called correctly
</span></span></span><span style=display:flex><span>    expect(mockDb.query).toHaveBeenCalledWith(
</span></span><span style=display:flex><span>      <span style=color:#f1fa8c>&#34;SELECT * FROM users WHERE id = $1&#34;</span>,
</span></span><span style=display:flex><span>      [<span style=color:#f1fa8c>&#34;unknown&#34;</span>]
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Verify logger was called
</span></span></span><span style=display:flex><span>    expect(mockLogger.info).toHaveBeenCalledWith(<span style=color:#f1fa8c>&#34;Fetching user unknown&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Result should be undefined when no rows returned
</span></span></span><span style=display:flex><span>    expect(result).toBeUndefined();
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>The example above demonstrates how the DI pattern simplifies mocking by eliminating the need to globally mock imports in your test suite. This naturally raises the question: <code>how do you implement DI with Express.js which is a framework designed around middlewares and functional programming?</code>. One option is integrating a library like <code>tsyringe</code> with Express.js. However, if the overhead of adding a third-party DI library feels excessive, it might be worth considering Nest.js instead, which has DI built into its core architecture.</p><p>While easier mocking is a nice benefit, the real power of DI becomes apparent when we want to write effective unit tests. In the next section, we&rsquo;ll explore how DI truly shines in making unit testing more practical and maintainable.</p><hr><h3 id=the-four-non-negotiables-of-effective-unit-tests>The FOUR Non-Negotiables of Effective Unit Tests<a hidden class=anchor aria-hidden=true href=#the-four-non-negotiables-of-effective-unit-tests>#</a></h3><h4 id=1-fast>1. FAST<a hidden class=anchor aria-hidden=true href=#1-fast>#</a></h4><p>The whole point of unit-tests is to save time for a developer. Test suit should run as quickly as hot reload responds to a code change with instant feedback. This is only possible when you mock external dependencies completely and run test cases in <strong>PARALLEL</strong>. If your test suite takes minutes, you&rsquo;ll stop running it.</p><h5 id=parallel-execution-the-global-imports-challenge>Parallel Execution: The Global Imports Challenge<a hidden class=anchor aria-hidden=true href=#parallel-execution-the-global-imports-challenge>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#6272a4>// src/services/__tests__/user.service.test.ts
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> { UserService } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../user.service&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Mock the entire module BEFORE importing the service
</span></span></span><span style=display:flex><span>jest.mock(<span style=color:#f1fa8c>&#34;../../db/client&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> ({
</span></span><span style=display:flex><span>  db<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>    query: <span style=color:#8be9fd>jest.fn</span>(),
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>}));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>jest.mock(<span style=color:#f1fa8c>&#34;../../utils/logger&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> ({
</span></span><span style=display:flex><span>  logger<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>    info: <span style=color:#8be9fd>jest.fn</span>(),
</span></span><span style=display:flex><span>    error: <span style=color:#8be9fd>jest.fn</span>(),
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>}));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Import the mocked module to control it in tests
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> { db } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../../db/client&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> { logger } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../../utils/logger&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>describe(<span style=color:#f1fa8c>&#34;UserService&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// âŒ REMOVED: shared `service` variable
</span></span></span><span style=display:flex><span>  <span style=color:#6272a4>// âŒ REMOVED: beforeEach with service instantiation
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// âœ… Only clear mocks before each test
</span></span></span><span style=display:flex><span>  beforeEach(() <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    jest.clearAllMocks();
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  test.concurrent(<span style=color:#f1fa8c>&#34;should fetch a user by id&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// âœ… Create service INSIDE the test
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> mockUser <span style=color:#ff79c6>=</span> { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;123&#34;</span>, name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;John Doe&#34;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// âœ… Use mockResolvedValueOnce (not mockResolvedValue)
</span></span></span><span style=display:flex><span>    (db.query <span style=color:#ff79c6>as</span> jest.Mock).mockResolvedValueOnce({ rows<span style=color:#ff79c6>:</span> [mockUser] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;123&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    expect(db.query).toHaveBeenCalledWith(<span style=color:#f1fa8c>&#34;SELECT * FROM users WHERE id = $1&#34;</span>, [
</span></span><span style=display:flex><span>      <span style=color:#f1fa8c>&#34;123&#34;</span>,
</span></span><span style=display:flex><span>    ]);
</span></span><span style=display:flex><span>    expect(result).toEqual(mockUser);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  test.concurrent(<span style=color:#f1fa8c>&#34;should handle user not found&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// âœ… Create service INSIDE the test
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// âœ… Use mockResolvedValueOnce (not mockResolvedValue)
</span></span></span><span style=display:flex><span>    (db.query <span style=color:#ff79c6>as</span> jest.Mock).mockResolvedValueOnce({ rows<span style=color:#ff79c6>:</span> [] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;unknown&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    expect(db.query).toHaveBeenCalledWith(<span style=color:#f1fa8c>&#34;SELECT * FROM users WHERE id = $1&#34;</span>, [
</span></span><span style=display:flex><span>      <span style=color:#f1fa8c>&#34;unknown&#34;</span>,
</span></span><span style=display:flex><span>    ]);
</span></span><span style=display:flex><span>    expect(result).toBeUndefined();
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h5 id=effortless-parallelization-the-di-advantage>Effortless Parallelization: The DI Advantage<a hidden class=anchor aria-hidden=true href=#effortless-parallelization-the-di-advantage>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#6272a4>// src/services/__tests__/user.service.test.ts
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> { UserService } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../user.service&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>describe(<span style=color:#f1fa8c>&#34;UserService&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// âŒ REMOVED: shared variables (service, mockDb, mockLogger)
</span></span></span><span style=display:flex><span>  <span style=color:#6272a4>// âŒ REMOVED: beforeEach with shared setup
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// âœ… Helper to create fresh mocks for each test
</span></span></span><span style=display:flex><span>  <span style=color:#ff79c6>const</span> createMocks <span style=color:#ff79c6>=</span> () <span style=color:#ff79c6>=&gt;</span> ({
</span></span><span style=display:flex><span>    mockDb<span style=color:#ff79c6>:</span> { query: <span style=color:#8be9fd>jest.fn</span>() },
</span></span><span style=display:flex><span>    mockLogger<span style=color:#ff79c6>:</span> { info: <span style=color:#8be9fd>jest.fn</span>(), error: <span style=color:#8be9fd>jest.fn</span>() },
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  test.concurrent(<span style=color:#f1fa8c>&#34;should fetch a user by id&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// âœ… Create fresh mocks INSIDE each test
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> { mockDb, mockLogger } <span style=color:#ff79c6>=</span> createMocks();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService(mockDb, mockLogger);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> mockUser <span style=color:#ff79c6>=</span> { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;123&#34;</span>, name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;John Doe&#34;</span> };
</span></span><span style=display:flex><span>    mockDb.query.mockResolvedValue({ rows<span style=color:#ff79c6>:</span> [mockUser] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;123&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    expect(mockDb.query).toHaveBeenCalledWith(
</span></span><span style=display:flex><span>      <span style=color:#f1fa8c>&#34;SELECT * FROM users WHERE id = $1&#34;</span>,
</span></span><span style=display:flex><span>      [<span style=color:#f1fa8c>&#34;123&#34;</span>]
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    expect(result).toEqual(mockUser);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  test.concurrent(<span style=color:#f1fa8c>&#34;should handle user not found&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// âœ… Create fresh mocks INSIDE each test
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> { mockDb, mockLogger } <span style=color:#ff79c6>=</span> createMocks();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService(mockDb, mockLogger);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mockDb.query.mockResolvedValue({ rows<span style=color:#ff79c6>:</span> [] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;unknown&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    expect(mockDb.query).toHaveBeenCalledWith(
</span></span><span style=display:flex><span>      <span style=color:#f1fa8c>&#34;SELECT * FROM users WHERE id = $1&#34;</span>,
</span></span><span style=display:flex><span>      [<span style=color:#f1fa8c>&#34;unknown&#34;</span>]
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    expect(mockLogger.info).toHaveBeenCalledWith(<span style=color:#f1fa8c>&#34;Fetching user unknown&#34;</span>);
</span></span><span style=display:flex><span>    expect(result).toBeUndefined();
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>DI gives each test case its own mock, so <code>mockResolvedValue</code> just works.
When you mock at the import level, Jest creates a single mock instance that&rsquo;s shared across all tests running in parallel. If you use <code>mockResolvedValue</code> instead of <code>mockResolvedValueOnce</code>, one test&rsquo;s setup can bleed into anotherâ€”leading to flaky failures that are notoriously hard to debug.</p><h4 id=2-isolation>2. Isolation<a hidden class=anchor aria-hidden=true href=#2-isolation>#</a></h4><p>Parallelism implies isolation. If your test cases run concurrently without failing, they have no shared state, no order dependencies, no hidden coupling. Test A can&rsquo;t break Test B.</p><h4 id=3-repeatable>3. Repeatable<a hidden class=anchor aria-hidden=true href=#3-repeatable>#</a></h4><p>A test case should give you the same result whether you run it once or a thousand times. Reformat your code, refactor internals, swap out the databaseâ€”No change. This leads to a critical point: test behavior, not implementation. The moment you assert &ldquo;this function was called exactly twice,&rdquo; you&rsquo;re testing how something works, not what it does.</p><p>This is why the logger assertion in our example is problematic:</p><p><code>âŒ expect(mockLogger.info).toHaveBeenCalledWith("Fetching user unknown");</code></p><p>Think about it: you could modify or remove this logging statement without breaking any functionality. That makes it an implementation detail, not a behavioral contract. Unit-tests that assert on implementation details break when you refactor which is exactly what <code>repeatable</code> guards against.</p><h4 id=4-aaa-pattern-arrange-act-assert>4. <a href=https://xp123.com/3a-arranged-act-assert/ target=_blank rel="noopener noreferrer">AAA pattern (Arrange, Act, Assert)</a> <a hidden class=anchor aria-hidden=true href=#4-aaa-pattern-arrange-act-assert>#</a></h4><p>Structure matters. Every test-case should follow this pattern:</p><ul><li>Arrange â€” set up your test data and dependencies</li><li>Act â€” execute <strong>ONE</strong> thing (a single function call, one operation)</li><li>Assert â€” verify the <strong>RETURNED</strong> values</li></ul><h5 id=-multiple-acts-in-one-test-case>âŒ Multiple Acts in One Test-case<a hidden class=anchor aria-hidden=true href=#-multiple-acts-in-one-test-case>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#ff79c6>import</span> { UserService } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../user.service&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>describe(<span style=color:#f1fa8c>&#34;UserService&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>const</span> createMocks <span style=color:#ff79c6>=</span> () <span style=color:#ff79c6>=&gt;</span> ({
</span></span><span style=display:flex><span>    mockDb<span style=color:#ff79c6>:</span> { query: <span style=color:#8be9fd>jest.fn</span>() },
</span></span><span style=display:flex><span>    mockLogger<span style=color:#ff79c6>:</span> { info: <span style=color:#8be9fd>jest.fn</span>(), error: <span style=color:#8be9fd>jest.fn</span>() },
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// âŒ VIOLATION: Multiple Acts in one test-case
</span></span></span><span style=display:flex><span>  it(<span style=color:#f1fa8c>&#34;should fetch and update user correctly&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// ARRANGE
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> { mockDb, mockLogger } <span style=color:#ff79c6>=</span> createMocks();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService(mockDb, mockLogger);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> mockUser <span style=color:#ff79c6>=</span> { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;123&#34;</span>, name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;John Doe&#34;</span> };
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> updatedUser <span style=color:#ff79c6>=</span> { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;123&#34;</span>, name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;Jane Doe&#34;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mockDb.query
</span></span><span style=display:flex><span>      .mockResolvedValueOnce({ rows<span style=color:#ff79c6>:</span> [mockUser] }) <span style=color:#6272a4>// for getUser
</span></span></span><span style=display:flex><span>      .mockResolvedValueOnce({ rows<span style=color:#ff79c6>:</span> [updatedUser] }); <span style=color:#6272a4>// for updateUser
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// ACT #1 âŒ First action
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> fetchedUser <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;123&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// ASSERT #1 âŒ Intermediate assertion
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    expect(fetchedUser).toEqual(mockUser);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// ACT #2 âŒ Second action
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.updateUser(<span style=color:#f1fa8c>&#34;123&#34;</span>, { name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;Jane Doe&#34;</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// ASSERT #2 âŒ Final assertion
</span></span></span><span style=display:flex><span>    <span style=color:#6272a4>// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</span></span></span><span style=display:flex><span>    expect(result).toEqual(updatedUser);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>This is problematic since it is a Test Failure Debugging Nightmare.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
</span></span><span style=display:flex><span>â”‚ Test<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;should fetch and update user correctly&#34;</span>          â”‚
</span></span><span style=display:flex><span>â”‚ Status: <span style=color:#8be9fd>FAILED</span> âŒ                                        â”‚
</span></span><span style=display:flex><span>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
</span></span><span style=display:flex><span>â”‚ Which action failed<span style=color:#ff79c6>?</span>                                    â”‚
</span></span><span style=display:flex><span>â”‚   â”œâ”€ getUser(<span style=color:#f1fa8c>&#39;123&#39;</span>)<span style=color:#ff79c6>?</span>                                    â”‚
</span></span><span style=display:flex><span>â”‚   â””â”€ updateUser(<span style=color:#f1fa8c>&#39;123&#39;</span>, ...)<span style=color:#ff79c6>?</span>                            â”‚
</span></span><span style=display:flex><span>â”‚                                                         â”‚
</span></span><span style=display:flex><span>â”‚ Which assertion failed<span style=color:#ff79c6>?</span>                                 â”‚
</span></span><span style=display:flex><span>â”‚   â”œâ”€ fetchedUser equals mockUser<span style=color:#ff79c6>?</span>                       â”‚
</span></span><span style=display:flex><span>â”‚   â”œâ”€ result equals updatedUser<span style=color:#ff79c6>?</span>                         â”‚
</span></span><span style=display:flex><span>â”‚                                                         â”‚
</span></span><span style=display:flex><span>â”‚ ğŸ¤· Hard to tell without reading stack trace             â”‚
</span></span><span style=display:flex><span>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span></code></pre></div><hr><h6 id=-refactored-into-separate-tests>âœ… Refactored into Separate Tests<a hidden class=anchor aria-hidden=true href=#-refactored-into-separate-tests>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#ff79c6>import</span> { UserService } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;../user.service&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>describe(<span style=color:#f1fa8c>&#34;UserService&#34;</span>, () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>const</span> createMocks <span style=color:#ff79c6>=</span> () <span style=color:#ff79c6>=&gt;</span> ({
</span></span><span style=display:flex><span>    mockDb<span style=color:#ff79c6>:</span> { query: <span style=color:#8be9fd>jest.fn</span>() },
</span></span><span style=display:flex><span>    mockLogger<span style=color:#ff79c6>:</span> { info: <span style=color:#8be9fd>jest.fn</span>(), error: <span style=color:#8be9fd>jest.fn</span>() },
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// âœ… Test 1: Single Act - getUser
</span></span></span><span style=display:flex><span>  test.concurrent(<span style=color:#f1fa8c>&#34;should fetch a user by id&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ARRANGE
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> { mockDb, mockLogger } <span style=color:#ff79c6>=</span> createMocks();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService(mockDb, mockLogger);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> mockUser <span style=color:#ff79c6>=</span> { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;123&#34;</span>, name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;John Doe&#34;</span> };
</span></span><span style=display:flex><span>    mockDb.query.mockResolvedValue({ rows<span style=color:#ff79c6>:</span> [mockUser] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ACT (single action)
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.getUser(<span style=color:#f1fa8c>&#34;123&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ASSERT
</span></span></span><span style=display:flex><span>    expect(result).toEqual(mockUser);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// âœ… Test 2: Single Act - updateUser
</span></span></span><span style=display:flex><span>  test.concurrent(<span style=color:#f1fa8c>&#34;should update a user&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ARRANGE
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> { mockDb, mockLogger } <span style=color:#ff79c6>=</span> createMocks();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService(mockDb, mockLogger);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> updatedUser <span style=color:#ff79c6>=</span> { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;123&#34;</span>, name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;Jane Doe&#34;</span> };
</span></span><span style=display:flex><span>    mockDb.query.mockResolvedValue({ rows<span style=color:#ff79c6>:</span> [updatedUser] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ACT (single action)
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.updateUser(<span style=color:#f1fa8c>&#34;123&#34;</span>, { name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;Jane Doe&#34;</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ASSERT
</span></span></span><span style=display:flex><span>    expect(result).toEqual(updatedUser);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// âœ… Test 3: Single Act - workflow (if testing integration)
</span></span></span><span style=display:flex><span>  test.concurrent(<span style=color:#f1fa8c>&#34;should fetch user before update&#34;</span>, <span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ARRANGE
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> { mockDb, mockLogger } <span style=color:#ff79c6>=</span> createMocks();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> service <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> UserService(mockDb, mockLogger);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> mockUser <span style=color:#ff79c6>=</span> { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;123&#34;</span>, name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;John Doe&#34;</span> };
</span></span><span style=display:flex><span>    mockDb.query.mockResolvedValue({ rows<span style=color:#ff79c6>:</span> [mockUser] });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ACT (single action - the workflow method)
</span></span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> service.fetchAndUpdateUser(<span style=color:#f1fa8c>&#34;123&#34;</span>, { name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;Jane&#34;</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ASSERT
</span></span></span><span style=display:flex><span>    expect(result.original.name).toBe(<span style=color:#f1fa8c>&#34;John Doe&#34;</span>);
</span></span><span style=display:flex><span>    expect(result.updated.name).toBe(<span style=color:#f1fa8c>&#34;Jane&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=the-bottom-line>The Bottom Line<a hidden class=anchor aria-hidden=true href=#the-bottom-line>#</a></h2><p>LLMs have fundamentally changed the economics of starting fresh. Prototyping is cheaper than ever. Setting up a project with <strong>testability as a first-class concern</strong> is no longer an expensive luxury but it&rsquo;s
becoming the default. Feed these guidelines to an LLM, and it can generate code structured exactly the way you want. That&rsquo;s what we&rsquo;ll explore in the next post.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://anmolgupta.github.io/>Anmol Gupta</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>